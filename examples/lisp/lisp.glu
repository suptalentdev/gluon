let prelude = import "std/prelude.glu"
let { List, Functor, Applicative, Monad, id } = prelude
let { (==) } = prelude.eq_Int
let { (==) } = prelude.eq_Float
let {
    Parser,
    functor,
    alternative,
    applicative,
    monad,
    fail,
    between,
    lazy_parser,
    many,
    one_of,
    satisfy,
    spaces,
    token,
    take_string,
    take1,
    skip_many,
    skip_many1
    } = import "std/parser.glu"

let string = import "std/string.glu"
let { (==) } = string.eq
let { (<>) } = prelude.make_Monoid string.monoid

type Expr =
    | Atom String
    | Int Int
    | Float Float
    | List (List Expr)

let eq : Eq Expr =
    let eq_expr l r : Expr -> Expr -> Bool =
        match l with
        | Atom ls ->
            match r with
            | Atom rs -> ls == rs
            | _ -> False
        | Int ls ->
            match r with
            | Int rs -> ls == rs
            | _ -> False
        | Float ls ->
            match r with
            | Float rs -> ls == rs
            | _ -> False
        | List ls ->
            match r with
            | List rs ->
                let list_eq: Eq (List Expr) = prelude.eq_List { (==) = eq_expr }
                list_eq.(==) ls rs
            | _ -> False
    { (==) = eq_expr }

let show : Show Expr =
    let spaced xs =
        match xs with
        | Cons y ys -> show y <> spaced1 ys
        | Nil -> ""
    and spaced1 xs =
        match xs with
        | Cons y ys -> " " <> show y <> spaced1 ys
        | Nil -> ""
    and show expr =
        match expr with
        | Atom s -> s
        | Int i -> prelude.show_Int.show i
        | Float f -> prelude.show_Float.show f
        | List ls -> "(" <> spaced ls <> ")"
    { show }

let { (<*), (*>), map2, pure } = prelude.make_Applicative applicative
let { (<|>) } = prelude.make_Alternative alternative
let { (>>=) } = prelude.make_Monad monad

let atom : Parser Expr =
    let symbol = one_of "!#$%&|*+-/:<=>?@^_~"
    let alpha = satisfy char.is_alphabetic
    let alpha_num = satisfy char.is_alphanumeric
    functor.map
        (\x -> Atom x)
        (take_string ((alpha <|> symbol) *> skip_many (alpha_num <|> symbol)))

let parse_parser p f msg: Parser a -> (String -> Result () b) -> String -> Parser b =
    take_string p >>= (\s ->
        match f s with
        | Ok i -> pure i
        | Err _ -> fail ("Expected " <> msg))

let int : Parser Expr =
    functor.map (\i -> Int i) (parse_parser (skip_many1 (satisfy char.is_numeric)) int.parse "integer")

let float : Parser Expr =
    let number = skip_many1 (satisfy char.is_numeric)
    functor.map
        (\f -> Float f)
        (parse_parser (number *> token '.' *> number) float.parse "float")

let list _ : () -> Parser Expr =
    let e = expr ()
    between (token '(') (token ')') (spaces *> functor.map (\x -> List x) (many e))
and expr _ : () -> Parser Expr = (atom <|> float <|> int <|> lazy_parser list) <* spaces


let map = import "std/map.glu"
let { Map } = map
let prim_map = map.make string.ord

type LispState = Map String Expr
type Lisp a = LispState -> Result String { value : a, state : LispState }

let lisp : Lisp a -> Lisp a = id

let functor_Lisp : Functor Lisp = {
    map = \f m -> lisp (\state ->
        match lisp m state with
        | Ok r -> Ok { value = f r.value, state = r.state }
        | Err err -> Err err)
}

let applicative_Lisp : Applicative Lisp = {
    functor = functor_Lisp,
    apply = \f m -> lisp (\state ->
        match lisp f state with
        | Ok g ->
            match lisp m g.state with
            | Ok r -> Ok { value = g.value r.value, state = r.state }
            | Err err -> Err err
        | Err err -> Err err),
    pure = \value -> lisp (\state -> Ok { value, state })
}

let { pure } = applicative_Lisp

let monad_Lisp : Monad Lisp = {
    applicative = applicative_Lisp,
    flat_map = \f m -> lisp (\state ->
        match lisp m state with
        | Ok r -> lisp (f r.value) r.state
        | Err err -> Err err)
}

let { (>>=), foldM } = prelude.make_Monad monad_Lisp

let fail msg : String -> Lisp a = lisp (\_ -> Err msg)

let primitive name int_op float_op
    : _ -> _ -> _ -> Map String (Expr -> Expr -> Lisp Expr) =
    prim_map.singleton name (\l r ->
        match l with
        | Int li ->
            match r with
            | Int ri -> pure (Int (int_op li ri))
            | _ -> fail ("Cant add " <> show.show r)
        | Float lf ->
            match r with
            | Float rf -> pure (Float (float_op lf rf))
            | _ -> fail ("Cant add " <> show.show r)
        | _ -> fail ("Cant add " <> show.show l)
        )

let primitives =
    let { (<>) = (++) } = prelude.make_Monoid prim_map.monoid
    primitive "+" (+) (+) ++
        primitive "-" (-) (-) ++
        primitive "*" (*) (*) ++
        primitive "/" (/) (/)

let eval_lisp expr : Expr -> Lisp Expr =
    match expr with
    | Atom _ -> fail "unimplemented"
    | Int _ -> pure expr
    | Float _ -> pure expr
    | List list ->
        match list with
        | Cons x xs ->
            match x with
            | Atom name ->
                match prim_map.find name primitives with
                | Some prim ->
                    match xs with
                    | Cons y ys ->
                        let arg_eval l r = eval_lisp r >>= (\a -> prim l a)
                        eval_lisp y >>= (\y -> foldM arg_eval y ys)
                    | Nil -> fail "Expected arguments to primitive"
                | None -> fail ("Primitive `" <> name <> "` does not exist")
            | _ -> fail ("Cant apply" <> show.show x)
        | Nil -> pure expr

let run_lisp expr env : Lisp a -> Map String Expr -> Result String a =
    prelude.functor_Result.map (\r -> r.value) (lisp expr env)

let eval expr : Expr -> Result String Expr =
    run_lisp (eval_lisp expr) prim_map.monoid.empty

{
    Expr,
    eq, show,
    expr = spaces *> lazy_parser expr,
    eval
}
