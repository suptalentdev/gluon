let prelude = import! "std/prelude.glu"
let { List, Functor, Applicative, Monad, id, list, len = list_len } = prelude
let { (==) } = prelude.eq_Int
let { (==) } = prelude.eq_Float
let {
    Parser,
    functor,
    alternative,
    applicative,
    monad,
    fail,
    between,
    lazy_parser,
    many,
    one_of,
    satisfy,
    spaces,
    token,
    take_string,
    take1,
    skip_many,
    skip_many1
    } = import! "std/parser.glu"

let string = import! "std/string.glu"
let { (==) } = string.eq
let { (<>) } = prelude.make_Monoid string.monoid

let map = import! "std/map.glu"
let { Map } = map
let prim_map = map.make string.ord

type Expr =
    | Atom String
    | Int Int
    | Float Float
    | List (List Expr)
    | Function Function
    | Primitive (List Expr -> Lisp Expr)
and Function = {
    params : Array String,
    vararg : Option String,
    body : List Expr,
    closure : Map String Expr
}
and LispState = Map String Expr
and Lisp a = LispState -> Result String { value : a, state : LispState }

let eq : Eq Expr =
    let eq_expr l r : Expr -> Expr -> Bool =
        match l with
        | Atom ls ->
            match r with
            | Atom rs -> ls == rs
            | _ -> False
        | Int ls ->
            match r with
            | Int rs -> ls == rs
            | _ -> False
        | Float ls ->
            match r with
            | Float rs -> ls == rs
            | _ -> False
        | List ls ->
            match r with
            | List rs ->
                let list_eq: Eq (List Expr) = prelude.eq_List { (==) = eq_expr }
                list_eq.(==) ls rs
            | _ -> False
    { (==) = eq_expr }

let show : Show Expr =
    let spaced show_ xs =
        match xs with
        | Cons y ys -> show_ y <> spaced1 show_ ys
        | Nil -> ""
    and spaced1 show_ xs =
        match xs with
        | Cons y ys -> " " <> show_ y <> spaced1 show_ ys
        | Nil -> ""
    let show expr =
        match expr with
        | Atom s -> s
        | Int i -> prelude.show_Int.show i
        | Float f -> prelude.show_Float.show f
        | List ls -> "(" <> spaced show ls <> ")"
        | Function f ->
            let vararg =
                match f.vararg with
                | Some arg -> " . " <> arg
                | None -> ""
            "(lambda (" <> spaced id (list f.params) <> ")" <> vararg <> ") ...)"
        | Primitive _ -> "<primitive>"
    { show }

let { (<*), (*>), map2, pure } = prelude.make_Applicative applicative
let { (<|>) } = prelude.make_Alternative alternative
let { (>>=) } = prelude.make_Monad monad

let atom : Parser Expr =
    let symbol = one_of "!#$%&|*+-/:<=>?@^_~"
    let alpha = satisfy char.is_alphabetic
    let alpha_num = satisfy char.is_alphanumeric
    functor.map
        (\x -> Atom x)
        (take_string ((alpha <|> symbol) *> skip_many (alpha_num <|> symbol)))

let parse_parser p f msg: Parser a -> (String -> Result () b) -> String -> Parser b =
    take_string p >>= (\s ->
        match f s with
        | Ok i -> pure i
        | Err _ -> fail ("Expected " <> msg))

let int : Parser Expr =
    functor.map (\i -> Int i) (parse_parser (skip_many1 (satisfy char.is_numeric)) int.parse "integer")

let float : Parser Expr =
    let number = skip_many1 (satisfy char.is_numeric)
    functor.map
        (\f -> Float f)
        (parse_parser (number *> token '.' *> number) float.parse "float")

let list _ : () -> Parser Expr =
    let e = expr ()
    between (token '(') (token ')') (spaces *> functor.map (\x -> List x) (many e))
and expr _ : () -> Parser Expr = (atom <|> float <|> int <|> lazy_parser list) <* spaces

let lisp : Lisp a -> Lisp a = id

let functor_Lisp : Functor Lisp = {
    map = \f m -> lisp (\state ->
        match lisp m state with
        | Ok r -> Ok { value = f r.value, state = r.state }
        | Err err -> Err err)
}

let applicative_Lisp : Applicative Lisp = {
    functor = functor_Lisp,
    apply = \f m -> lisp (\state ->
        match lisp f state with
        | Ok g ->
            match lisp m g.state with
            | Ok r -> Ok { value = g.value r.value, state = r.state }
            | Err err -> Err err
        | Err err -> Err err),
    pure = \value -> lisp (\state -> Ok { value, state })
}

let { pure } = applicative_Lisp

let monad_Lisp : Monad Lisp = {
    applicative = applicative_Lisp,
    flat_map = \f m -> lisp (\state ->
        match lisp m state with
        | Ok r -> lisp (f r.value) r.state
        | Err err -> Err err)
}

let { (>>=), foldM, mapM } = prelude.make_Monad monad_Lisp
let { map = map_lisp } = functor_Lisp

let get_state : Lisp LispState = lisp (\state -> Ok { value = state.state, state = state.state })

let fail msg : String -> Lisp a = lisp (\_ -> Err msg)

let primitive name f : String -> _ -> Map String Expr =
    prim_map.singleton name (Primitive f)

type Binop a = a -> a -> a

let primitive_binop name int_op float_op : _ -> Binop Int -> Binop Float -> Map String Expr =
    let unpack x : Expr -> Lisp Int =
        match x with
        | Int i -> pure i
        | _ -> fail "Expected integer"
    let unpack x : Expr -> Lisp Float =
        match x with
        | Float f -> pure f
        | _ -> fail "Expected float"
    
    let fold unpack op = foldM (\acc x -> map_lisp (\y -> op acc y) (unpack x))

    let f xs : List Expr -> Lisp Expr =
        match xs with
        | Cons l ys ->
            match l with
            | Int li ->
                map_lisp Int (fold unpack int_op li ys)
            | Float lf ->
                map_lisp Float (fold unpack float_op lf ys)
            | _ -> fail ("Cant add " <> show.show l)
        | _ -> fail ("Expected two arguments to binop, got " <> show.show (List xs))
    primitive name f

let define =
    let f xs =
        match xs with
        | Cons (Cons (Atom name) params) body ->
            get_state >>= (\closure ->
                pure (Function {
                    params = prelude.functor_List.map show.show params,
                    vararg = None,
                    body,
                    closure
                })
            )
        | _ -> fail "Unexpected parameters to define `define`"
    primitive "define" f

let primitives =
    let { (<>) = (++) } = prelude.make_Monoid prim_map.monoid
    primitive_binop "+" (+) (+) ++
        primitive_binop "-" (-) (-) ++
        primitive_binop "*" (*) (*) ++
        primitive_binop "/" (/) (/)

let apply f xs =
    match f with
    | Primitive primitive -> primitive xs
    | _ -> fail "Can't call value"

let eval_lisp expr : Expr -> Lisp Expr =
    match expr with
    | Atom _ -> fail "unimplemented"
    | Int _ -> pure expr
    | Float _ -> pure expr
    | Function _ -> pure expr
    | List list ->
        match list with
        | Cons x xs ->
            match x with
            | Atom name ->
                match prim_map.find name primitives with
                | Some prim ->
                    mapM eval_lisp xs >>= \evaluated_args ->
                        apply prim evaluated_args
                | None -> fail ("Primitive `" <> name <> "` does not exist")
            | _ -> fail ("Cant apply" <> show.show x)
        | Nil -> pure expr

let run_lisp expr env : Lisp a -> Map String Expr -> Result String a =
    prelude.functor_Result.map (\r -> r.value) (lisp expr env)

let eval expr : Expr -> Result String Expr =
    run_lisp (eval_lisp expr) prim_map.monoid.empty

{
    Expr,
    eq, show,
    expr = spaces *> lazy_parser expr,
    eval
}
