let prelude = import "std/prelude.glu"
let { List } = prelude
let { (==) } = prelude.eq_Int
let { (==) } = prelude.eq_Float
let {
    Parser,
    functor,
    alternative,
    applicative,
    monad,
    fail,
    between,
    lazy_parser,
    many,
    one_of,
    satisfy,
    spaces,
    token,
    take_string,
    take1,
    skip_many,
    skip_many1
    } = import "std/parser.glu"

let string = import "std/string.glu"
let { (==) } = string.eq
let { (<>) } = prelude.make_Monoid string.monoid

type Expr =
    | Atom String
    | Int Int
    | Float Float
    | List (List Expr)

let eq : Eq Expr =
    let eq_expr l r : Expr -> Expr -> Bool =
        match l with
        | Atom ls ->
            match r with
            | Atom rs -> ls == rs
            | _ -> False
        | Int ls ->
            match r with
            | Int rs -> ls == rs
            | _ -> False
        | Float ls ->
            match r with
            | Float rs -> ls == rs
            | _ -> False
        | List ls ->
            match r with
            | List rs ->
                let list_eq: Eq (List Expr) = prelude.eq_List { (==) = eq_expr }
                list_eq.(==) ls rs
            | _ -> False
    { (==) = eq_expr }

let show : Show Expr =
    let spaced xs =
        match xs with
        | Cons y ys -> show y <> spaced1 ys
        | Nil -> ""
    and spaced1 xs =
        match xs with
        | Cons y ys -> " " <> show y <> spaced1 ys
        | Nil -> ""
    and show expr =
        match expr with
        | Atom s -> s
        | Int i -> prelude.show_Int.show i
        | Float f -> prelude.show_Float.show f
        | List ls -> "(" <> spaced ls <> ")"
    { show }

let { (<*), (*>), map2, pure } = prelude.make_Applicative applicative
let { (<|>) } = prelude.make_Alternative alternative
let { (>>=) } = prelude.make_Monad monad

let atom : Parser Expr =
    let symbol = one_of "!#$%&|*+-/:<=>?@^_~"
    let alpha = satisfy char.is_alphabetic
    let alpha_num = satisfy char.is_alphanumeric
    functor.map
        (\x -> Atom x)
        (take_string ((alpha <|> symbol) *> skip_many (alpha_num <|> symbol)))

let parse_parser p f msg: Parser a -> (String -> Result () b) -> String -> Parser b =
    take_string p >>= (\s ->
        match f s with
        | Ok i -> pure i
        | Err _ -> fail ("Expected " <> msg))

let int : Parser Expr =
    functor.map (\i -> Int i) (parse_parser (skip_many1 (satisfy char.is_numeric)) int.parse "integer")

let float : Parser Expr =
    let number = skip_many1 (satisfy char.is_numeric)
    functor.map
        (\f -> Float f)
        (parse_parser (number *> token '.' *> number) float.parse "float")

let list _ : () -> Parser Expr =
    let e = expr ()
    between (token '(') (token ')') (spaces *> functor.map (\x -> List x) (many e))
and expr _ : () -> Parser Expr = (atom <|> float <|> int <|> lazy_parser list) <* spaces

let map = import "std/map.glu"
let { Map } = map
let prim_map = map.make string.ord
//let { (<>) } = prelude.make_Monoid prim_map.monoid

let primitives = prim_map.singleton "+" (\l r ->
    match l with
    | Int li ->
        match r with
        | Int ri -> Ok (Int (li + ri))
        | _ -> Err ("Cant add " <> show.show r)
    | Float lf ->
        match r with
        | Float rf -> Ok (Float (lf + rf))
        | _ -> Err ("Cant add " <> show.show r)
    | _ -> Err ("Cant add " <> show.show l)
    )

let { foldM } = prelude.make_Monad prelude.monad_Result

let eval expr : Expr -> Result String Expr =
    match expr with
    | Atom _ -> Err "unimplemented"
    | Int _ -> Ok expr
    | Float _ -> Ok expr
    | List list ->
        match list with
        | Cons x xs ->
            match x with
            | Atom name ->
                match prim_map.find name primitives with
                | Some prim ->
                    match xs with
                    | Cons y ys -> foldM prim y ys
                    | Nil -> Err "Expected arguments to primitive"
                | None -> Err ("Primitive `" <> name <> "` does not exist")
            | _ -> Err ("Cant apply" <> show.show x)
        | Nil -> Ok expr

{
    Expr,
    eq, show,
    expr = spaces *> lazy_parser expr,
    eval
}
