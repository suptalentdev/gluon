let prelude = import! "std/prelude.glu"
let string = import! "std/string.glu"
let { (==) } = string.eq
let { Functor, Applicative, Alternative, Monad } = prelude
let { (<<), id } = prelude.make_Category prelude.category_Function
let { pure } = prelude.applicative_IO

let {
    Method,
    Failure,
    Request,
    StatusCode,
    Response,
    Handler } = import! "examples/http_types.glu"

/// Force the value to be a Handler. Used to make the the type inference work for higher-kinded types
let make: Handler a -> Handler a = id

let functor: Functor Handler = {
    map = \f handler ->
        // FIXME type inference fails without this
        let handler = make handler
        make (\success failure request -> handler (success << f) failure request)
}

let flat_map f handler: (a -> Handler b) -> Handler a -> Handler b =
    // FIXME type inference fails without this
    let handler = make handler
    make (\success failure request ->
        let success2 a r = make (f a) success failure request
        handler success2 failure request)


let applicative: Applicative Handler = {
    functor,
    apply = \a m ->
        let m = make m
        flat_map (\f -> functor.map f m) a,
    pure = \a -> make (\success _ request -> success a request)
}
let { (*>) } = prelude.make_Applicative applicative

let alternative: Alternative Handler = {
    applicative,
    // Tries to handle the request with `l`, if it fails with `DontProcess` then `r` is tried instead
    or = \l r -> make (\success failure request ->
        let failure2 reason request2 =
            match reason with
            | DontProcess -> make r success failure request2
            | Error _ -> failure reason request2

        make l success failure2 request),
    empty = make (\_ failure request -> failure DontProcess request)
}
let { or, empty, (<|>) } = prelude.make_Alternative alternative

let monad: Monad Handler = {
    applicative,
    flat_map
}

/// Handles the request if `predicate` returns `True
let test predicate: (Request -> Bool) -> Handler () =
    \success failure request ->
        if predicate request then
            success () request
        else
            failure DontProcess request

/// Handles `Get` requests
let get : Handler () =
    test (\request ->
        match request.method with
        | Get -> True
        | _ -> False)

/// Handles `Post` requests
let post : Handler () =
    test (\request ->
        match request.method with
        | Post -> True
        | _ -> False)

let path uri: String -> Handler () =
    test (\request -> request.uri == uri)

/// Retrieves the HTTP request
let get_request : Handler Request =
    \success _ request -> success request request

let empty_response = { status = OK, body = "" }

let io_handler io: IO a -> Handler a =
    make (\success _ request -> prelude.monad_IO.flat_map (\a -> success a request) io)

let fail msg : String -> Handler a =
    make (\_ failure request -> failure (Error msg) request)

let catch_error action catch : Handler a -> (String -> Handler a) -> Handler a =
    make (\success failure request ->
        let failure2 reason request2 =
            match reason with
            | DontProcess -> failure reason request2
            | Error msg -> catch msg success failure request2
        action success failure2 request)

/// Takes a `Handler` and a `Request` tries to process the request
let handle handler request : Handler Response -> Request -> IO Response =
    let not_found _ _ =
        pure { status = NotFound, body = "Page not found" }
    handler (\response _ -> pure response) not_found request 

{
    Method,
    Failure,
    Request,
    StatusCode,
    Response,
    Handler,

    functor,
    applicative,
    alternative,
    monad,

    empty_response,
    get_request,
    handle,
    get,
    post,
    path,
    listen = http_prim.listen,
    read_chunk = http_prim.read_chunk,
    io_handler,
    fail,
    catch_error
}
