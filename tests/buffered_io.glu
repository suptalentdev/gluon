//! Tests for the buffered io found in `std.io.read` and `std.io.write`. Because
//! the tests run in the IO Monad, these tests currently don't play nice with
//! `std.test`. With effects, this should be updated to run with `std.test`.

let { assert }  = import! std.test
let { wrap } = import! std.applicative
let { (<|), (|>) } = import! std.function
let { ? } = import! std.io
let io_read @ { Read, default_read_to_end, read, read_to_end, ? } = import! std.io.read
let io_write @ { Write, write_slice, write, write_all, flush, ? } = import! std.io.write
let { ref, (<-), load } = import! std.reference
let { min } = import! std.cmp
let { ? } = import! std.byte
let array @ { ? } = import! std.array


type Cursor = {
    pos : Ref Int,
    buf : Array Byte
}

let cursor buf : Array Byte -> Cursor = {
    pos = ref 0,
    buf,
}

let read_cursor : Read Cursor =
    let read cursor num_bytes : Cursor -> Int -> IO (Option (Array Byte)) =
        let start = load cursor.pos
        let end = min (array.len cursor.buf) (start + num_bytes)
        let read_bytes = array.slice cursor.buf start end
        cursor.pos <- (start + array.len read_bytes)

        if array.is_empty read_bytes then
            wrap None
        else
            wrap (Some read_bytes)

    {
        read,
        read_to_end = default_read_to_end read
    }

let write_array_ref : Write (Ref (Array Byte)) = {
    write_slice = \array_ref buf start end ->
        let written = array.append (load array_ref) (array.slice buf start end)
        array_ref <- written
        wrap (end - start),
        
    flush = \_ -> wrap ()
}


let test_read _ =
    let reader = cursor [1b, 2b, 3b, 4b, 5b] |> io_read.buffered_with_capacity 4

    do bytes = read reader 2
    assert (bytes == Some [1b, 2b])

    do bytes = read reader 3
    assert (bytes == Some [3b, 4b])

    do bytes = read reader 9000
    assert (bytes == Some [5b])

    do bytes = read reader 9000
    assert (bytes == None)
    
    // read directly if buffer is empty
    let reader = cursor [1b, 2b, 3b, 4b, 5b] |> io_read.buffered_with_capacity 2
    do bytes = read reader 5
    assert (bytes == Some [1b, 2b, 3b, 4b, 5b])

    // read rest of buffer if it still holds data
    let reader = cursor [1b, 2b, 3b, 4b, 5b] |> io_read.buffered_with_capacity 2
    do _ = read reader 1
    do bytes = read reader 4
    assert (bytes == Some [2b])
    
    wrap ()
    
let test_read_to_end _ =
    // read all in one go
    let reader = cursor [1b, 2b, 3b, 4b, 5b] |> io_read.buffered_with_capacity 5
    do bytes = read_to_end reader
    assert (bytes == [1b, 2b, 3b, 4b, 5b])

    // read with small buffer
    let reader = cursor [1b, 2b, 3b, 4b, 5b] |> io_read.buffered_with_capacity 1
    do bytes = read_to_end reader
    assert (bytes == [1b, 2b, 3b, 4b, 5b])

    // read with part of buffer already read
    let reader = cursor [1b, 2b, 3b, 4b, 5b] |> io_read.buffered_with_capacity 2
    do _ = read reader 1
    do bytes = read_to_end reader
    assert (bytes == [2b, 3b, 4b, 5b])
    wrap ()

let test_write_and_flush _ =
    // buffer all data if it fits
    let written : Ref (Array Byte) = ref []
    let writer = written |> io_write.buffered_with_capacity 5

    do bytes_written = write writer [1b, 2b]
    assert (bytes_written == 2)
    assert (load written == [])
    do _ = flush writer
    assert (load written == [1b, 2b])
    
    // flush immediately if buffer is empty and new data wouldn't fit
    let written : Ref (Array Byte) = ref []
    let writer = written |> io_write.buffered_with_capacity 2

    do bytes_written = write writer [1b, 2b, 3b]
    assert (bytes_written == 3)
    assert (load written == [1b, 2b, 3b])
    do _ = flush writer
    assert (load written == [1b, 2b, 3b])

    // flush buffer and then write new data if it wouldn't fit the buffer
    let written : Ref (Array Byte) = ref []
    let writer = written |> io_write.buffered_with_capacity 2

    do bytes_written = write writer [1b]
    assert (bytes_written == 1)
    assert (load written == [])
    do bytes_written = write writer [2b, 3b]
    assert (bytes_written == 2)
    assert (load written == [1b, 2b, 3b])
    do _ = flush writer
    assert (load written == [1b, 2b, 3b])

    // flush buffer if new data doesn't fit, then buffer the data
    let written : Ref (Array Byte) = ref []
    let writer = written |> io_write.buffered_with_capacity 5

    do bytes_written = write writer [1b, 2b, 3b]
    assert (bytes_written == 3)
    assert (load written == [])
    do bytes_written = write writer [4b, 5b, 6b]
    assert (bytes_written == 3)
    assert (load written == [1b, 2b, 3b])
    do _ = flush writer
    assert (load written == [1b, 2b, 3b, 4b, 5b, 6b])

    wrap ()

let test_write_slice _ =
    // empty slice
    let written : Ref (Array Byte) = ref []
    let writer = written |> io_write.buffered_with_capacity 5
    do bytes_written = write_slice writer [1b, 2b, 3b, 4b] 0 0
    assert (bytes_written == 0)
    do _ = flush writer
    assert (load written == [])

    // slice
    let written : Ref (Array Byte) = ref []
    let writer = written |> io_write.buffered_with_capacity 5
    do bytes_written = write_slice writer [1b, 2b, 3b, 4b] 1 3
    assert (bytes_written == 2)
    do _ = flush writer
    assert (load written == [2b, 3b])

    // slice everything
    let written : Ref (Array Byte) = ref []
    let writer = written |> io_write.buffered_with_capacity 5
    do bytes_written = write_slice writer [1b, 2b, 3b, 4b] 0 4
    assert (bytes_written == 4)
    do _ = flush writer
    assert (load written == [1b, 2b, 3b, 4b])

    wrap ()

let test_write_all _ =
    let written : Ref (Array Byte) = ref []
    let writer = written |> io_write.buffered_with_capacity 1
    do _ = write_all writer [1b, 2b, 3b, 4b]
    do _ = flush writer
    assert (load written == [1b, 2b, 3b, 4b])

    // write the data that's already buffered too
    let written : Ref (Array Byte) = ref []
    let writer = written |> io_write.buffered_with_capacity 2
    do _ = write writer [1b]
    do _ = write_all writer [2b, 3b, 4b]
    do _ = flush writer
    assert (load written == [1b, 2b, 3b, 4b])

    wrap ()


do _ = test_read ()
do _ = test_read_to_end ()
do _ = test_write_and_flush ()
do _ = test_write_slice ()
test_write_all ()
