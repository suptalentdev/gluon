let prelude  = import! "std/prelude.glu"
let { Option, List, Eq, Show, list } = prelude
let string  = import! "std/string.glu"
let { (==) } = string.eq
let { (<>) } = prelude.make_Semigroup string.semigroup
let { Test, run, writer, assert, assert_eq }  = import! "std/test.glu"
let map  = import! "std/map.glu"
let { (*>) } = prelude.make_Applicative writer.applicative

let show_Entry : Show { key : String, value : Int } = {
    show = \e -> e.key <> prelude.show_Int.show e.value
}

let eq_Entry : Eq { key : String, value : Int } = {
    (==) = \l r -> l.key == r.key && l.value == r.value
}

let assert_entries =
    assert_eq (prelude.show_List show_Entry)
              (prelude.eq_List eq_Entry)

let assert_keys =
    assert_eq (prelude.show_List string.show)
              (prelude.eq_List string.eq)

let assert_values =
    assert_eq (prelude.show_List prelude.show_Int)
              (prelude.eq_List prelude.eq_Int)

let assert_opt =
    assert_eq (prelude.show_Option prelude.show_Int)
              (prelude.eq_Option prelude.eq_Int)

let ord_map = map.make string.ord
let { singleton, find, insert, to_list, keys, values } = ord_map
let { (<>) } = prelude.make_Semigroup ord_map.semigroup
let { empty } = ord_map.monoid

let basic_tests =
    let test_map = singleton "test" 1 <> singleton "asd" 2 <> singleton "a" 3

    assert_opt (find "test" test_map) (Some 1)
        *> assert_opt (find "asd" test_map) (Some 2)
        *> assert_opt (find "b" test_map) None
        *> assert_opt (find "test" (insert "test" 10 test_map)) (Some 10)
        *> assert_opt (find "test" test_map) (Some 1)
        *> assert_entries (to_list test_map) (list [{ key = "a", value = 3 },
                                                    { key = "asd", value = 2 },
                                                    { key = "test", value = 1 }])
        *> assert_keys (keys test_map) (list ["a", "asd", "test"])
        *> assert_values (values test_map) (list [3, 2, 1])
        *> assert_entries (to_list (test_map <> empty)) (to_list test_map)
        *> assert_entries (to_list (empty <> test_map)) (to_list test_map)

let append_tests =
    let test_map1 = singleton "a" 1 <> singleton "b" 2 <> singleton "c" 3
    let test_map2 = singleton "+" 1 <> (singleton "-" 2 <> singleton "*" 3)
    assert_opt (find "b" test_map1) (Some 2)
        *> assert_opt (find "*" test_map2) (Some 3)

run (basic_tests *> append_tests)
