let prelude  = import! "std/prelude.glu"
let { Eq, Show } = prelude
let option = import! "std/option.glu"
let { Option } = option
let string  = import! "std/string.glu"
let { (==) } = string.eq
let { (<>) } = prelude.make_Semigroup string.semigroup
let { Test, run, writer, assert, assert_eq }  = import! "std/test.glu"
let map  = import! "std/map.glu"
let { (*>) } = prelude.make_Applicative writer.applicative
let list = import! "std/list.glu"
let { List } = list

let show_Entry : Show { key : String, value : Int } = {
    show = \e -> e.key <> prelude.show_Int.show e.value
}

let eq_Entry : Eq { key : String, value : Int } = {
    (==) = \l r -> l.key == r.key && l.value == r.value
}

let assert_entries =
    assert_eq (list.show show_Entry)
              (list.eq eq_Entry)

let assert_keys =
    assert_eq (list.show string.show)
              (list.eq string.eq)

let assert_values =
    assert_eq (list.show prelude.show_Int)
              (list.eq prelude.eq_Int)

let assert_opt =
    assert_eq (option.show prelude.show_Int)
              (option.eq prelude.eq_Int)

let ord_map = map.make string.ord
let { singleton, find, insert, to_list, keys, values } = ord_map
let { (<>) } = prelude.make_Semigroup ord_map.semigroup
let { empty } = ord_map.monoid

let basic_tests =
    let test_map = singleton "test" 1 <> singleton "asd" 2 <> singleton "a" 3

    assert_opt (find "test" test_map) (Some 1)
        *> assert_opt (find "asd" test_map) (Some 2)
        *> assert_opt (find "b" test_map) None
        *> assert_opt (find "test" (insert "test" 10 test_map)) (Some 10)
        *> assert_opt (find "test" test_map) (Some 1)
        *> assert_entries (to_list test_map) (list.of [{ key = "a", value = 3 },
                                                       { key = "asd", value = 2 },
                                                       { key = "test", value = 1 }])
        *> assert_keys (keys test_map) (list.of ["a", "asd", "test"])
        *> assert_values (values test_map) (list.of [3, 2, 1])
        *> assert_entries (to_list (test_map <> empty)) (to_list test_map)
        *> assert_entries (to_list (empty <> test_map)) (to_list test_map)

let append_tests =
    let test_map1 = singleton "a" 1 <> singleton "b" 2 <> singleton "c" 3
    let test_map2 = singleton "+" 1 <> (singleton "-" 2 <> singleton "*" 3)
    assert_opt (find "b" test_map1) (Some 2)
        *> assert_opt (find "*" test_map2) (Some 3)

run (basic_tests *> append_tests)
