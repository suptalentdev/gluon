extern crate gluon;
#[macro_use]
extern crate gluon_codegen;
extern crate serde;
#[macro_use]
extern crate serde_derive;
#[macro_use]
extern crate gluon_vm;

mod init;

use gluon::vm::{self, ExternModule};
use gluon::{import, Compiler, Thread};
use init::new_vm;

#[derive(Debug, PartialEq, Getable, Pushable, VmType, Serialize, Deserialize)]
#[gluon(vm_type = "types.Struct")]
struct Struct {
    string: String,
    number: u32,
    vec: Vec<f64>,
}

fn load_struct_mod(vm: &Thread) -> vm::Result<ExternModule> {
    let module = record! {
        new_struct => primitive!(1 new_struct),
    };

    ExternModule::new(vm, module)
}

fn new_struct(_: ()) -> Struct {
    Struct {
        string: "hello".to_owned(),
        number: 1,
        vec: vec![1.0, 2.0, 3.0],
    }
}

#[test]
fn normal_struct() {
    let vm = new_vm();
    let mut compiler = Compiler::new();

    // must be generated by hand because of bug in make_source (see #542)
    let src = r#"
        type Struct = { string: String, number: Int, vec: Array Float }
        { Struct }
    "#;

    compiler.load_script(&vm, "types", &src).unwrap();
    import::add_extern_module(&vm, "functions", load_struct_mod);

    let script = r#"
        let { new_struct } = import! functions
        
        new_struct ()
    "#;

    let (s, _) = compiler
        .run_expr::<Struct>(&vm, "test", script)
        .unwrap_or_else(|why| panic!("{}", why));

    assert_eq!(
        s,
        Struct {
            string: "hello".into(),
            number: 1,
            vec: vec![1.0, 2.0, 3.0],
        }
    );
}
