let { Bool, Option, Ordering } = import! "std/types.glu"

let unwrap opt : Option a -> a =
    match opt with
    | Some x -> x
    | None -> error "Option was None"

/// Boolean 'not'
let not x : Bool -> Bool = if x then False else True

/// Boolean 'exclusive or'
let xor x y : Bool -> Bool -> Bool = if x then not y else y

/// `Semigroup a` represents an associative operation on `a`.
/// This means the following laws must hold:
///
/// * `forall x . append x (append y z) == append (append x y) z`
type Semigroup a = {
    /// # Note
    ///
    /// * Known as `(<>)` or `mappend` in Haskell
    append : a -> a -> a
}

let make_Semigroup semigroup : Semigroup a -> _ =
    let { append } = semigroup

    let (<>) : a -> a -> a = append

    { append, (<>) }

let semigroup_Function semigroup : Semigroup b -> Semigroup (a -> b) = {
    append = \f g x -> semigroup.append (f x) (g x)
}

let semigroup_Option semigroup : Semigroup a -> Semigroup (Option a) = {
    append = \l r ->
        match (l, r) with
        | (Some x, Some y) -> Some (semigroup.append x y)
        | (Some _, None) -> l
        | (None, Some _) -> r
        | (None, None) -> None
}

let semigroup_Option_First : Semigroup (Option a) = {
    append = \l r ->
        match l with
        | Some x -> Some x
        | None -> r
}

let semigroup_Option_Last : Semigroup (Option a) = {
    append = \l r ->
        match r with
        | Some x -> Some x
        | None -> l
}

let semigroup_Int_Add : Semigroup Int = { append = \x y -> x #Int+ y }

let semigroup_Int_Mul : Semigroup Int = { append = \x y -> x #Int* y }

let semigroup_Float_Add : Semigroup Float = { append = \x y -> x #Float+ y }

let semigroup_Float_Mul : Semigroup Float = { append = \x y -> x #Float* y }

let semigroup_Bool_And : Semigroup Bool = { append = \x y -> x && y }

let semigroup_Bool_Or : Semigroup Bool = { append = \x y -> x || y }

let semigroup_Bool_Xor : Semigroup Bool = { append = xor }

let semigroup_Ordering : Semigroup Ordering = {
    append = \x y ->
        match x with
        | EQ -> y
        | _ -> x
}

/// `Monoid a` represents an semigroup an which has an identity. This means
/// the following additional laws must hold:
///
/// * `forall x . append x empty == x`
/// * `forall x . append empty x == x`
type Monoid a = {
    semigroup : Semigroup a,
    /// # Note
    ///
    /// * Known as `mempty` in Haskell
    empty : a
}

let monoid_Function monoid : Monoid b -> Monoid (a -> b) = {
    semigroup = semigroup_Function monoid.semigroup,
    empty = \_ -> monoid.empty
}

let monoid_Option semigroup : Semigroup a -> Monoid (Option a) = {
    semigroup = semigroup_Option semigroup,
    empty = None
}

let monoid_Option_First : Monoid (Option a) = {
    semigroup = semigroup_Option_First,
    empty = None
}

let monoid_Option_Last : Monoid (Option a) = {
    semigroup = semigroup_Option_Last,
    empty = None
}

let monoid_Int_Add : Monoid Int = {
    semigroup = semigroup_Int_Add,
    empty = 0
}

let monoid_Int_Mul : Monoid Int = {
    semigroup = semigroup_Int_Mul,
    empty = 1
}

let monoid_Float_Add : Monoid Float = {
    semigroup = semigroup_Float_Add,
    empty = 0.0
}

let monoid_Float_Mul : Monoid Float = {
    semigroup = semigroup_Float_Mul,
    empty = 1.0
}

let monoid_Bool_And : Monoid Bool = {
    semigroup = semigroup_Bool_And,
    empty = True
}

let monoid_Bool_Or : Monoid Bool = {
    semigroup = semigroup_Bool_Or,
    empty = False
}

let monoid_Bool_Xor : Monoid Bool = {
    semigroup = semigroup_Bool_Xor,
    empty = False
}

let monoid_Ordering : Monoid Ordering = {
    semigroup = semigroup_Ordering,
    empty = EQ
}

/// `Group a` represents an monoid an which has an inverse element. This means
/// the following additional laws must hold:
///
/// * `forall x . append (inverse x) x = empty = append x (inverse x)`
type Group a = {
    monoid : Monoid a,
    /// The inverse operation
    inverse : a -> a
}

let group_Int_Add : Group Int = {
    monoid = monoid_Int_Add,
    inverse = \x -> 0 #Int- x
}

let group_Float_Add : Group Float = {
    monoid = monoid_Float_Add,
    inverse = \x -> 0.0 #Float- x
}

let group_Float_Mul : Group Float = {
    monoid = monoid_Float_Mul,
    inverse = \x -> 1.0 #Float/ x
}

let group_Bool_Xor : Group Bool = {
    monoid = monoid_Bool_Xor,
    inverse = \x -> x
}

/// `Eq a` defines equality (==) on `a`
type Eq a = { (==) : a -> a -> Bool }

let eq_Unit : Eq () = { (==) = \l r -> True }

let eq_Bool : Eq Bool = { (==) = \l r -> if l then r else not r }

let eq_Int = { (==) = \l r -> l #Int== r }

let eq_Float = { (==) = \l r -> l #Float== r }

let eq_Char = { (==) = \l r -> l #Char== r }

let eq_Option a : Eq a -> Eq (Option a) = {
    (==) = \l r ->
        match (l, r) with
        | (Some l_val, Some r_val) -> a.(==) l_val r_val
        | (None, None) -> True
        | _ -> False
}

/// `Ord a` defines an ordering on `a`
type Ord a = { eq : Eq a, compare : a -> a -> Ordering }

/// Creates the `<=`, `<`, `>` and `>=` operators from an instance with `Ord`
let make_Ord ord : Ord a -> _ =
    let { eq, compare } = ord

    let (<=) : a -> a -> Bool = \l r ->
        match compare l r with
        | LT -> True
        | EQ -> True
        | GT -> False

    let (<) : a -> a -> Bool = \l r ->
        match compare l r with
        | LT -> True
        | EQ -> False
        | GT -> False

    let (>) : a -> a -> Bool = \l r ->
        match compare l r with
        | LT -> False
        | EQ -> False
        | GT -> True

    let (>=) : a -> a -> Bool = \l r ->
        match compare l r with
        | LT -> False
        | EQ -> True
        | GT -> True

    { eq, compare, (<=), (<), (>), (>=) }

let ord_Unit = { eq = eq_Unit, compare = \l r -> EQ }

let ord_Bool = { eq = eq_Bool, compare = \l r -> if l then if r then EQ else GT else LT }

let ord_Int = {
    eq = eq_Int,
    compare = \l r -> if l #Int< r then LT else if l #Int== r then EQ else GT
}

let ord_Float = {
    eq = eq_Float,
    compare = \l r -> if l #Float< r then LT else if l #Float== r then EQ else GT
}

let ord_Char = {
    eq = eq_Char,
    compare = \l r -> if l #Char< r then LT else if l #Char== r then EQ else GT
}

let ord_Option a : Ord a -> Ord (Option a) = {
    eq = eq_Option a.eq,
    compare = \l r ->
        match (l, r) with
        | (Some l_val, Some r_val) -> a.compare l_val r_val
        | (None, Some _) -> LT
        | (Some _, None) -> GT
        | (None, None) -> EQ
}

/**
 The basic operation on numbers.
 Defined for both the primitive type `Int` and `Float`
*/
type Num a = {
    ord : Ord a,
    (+) : a -> a -> a,
    (-) : a -> a -> a,
    (*) : a -> a -> a,
    (/) : a -> a -> a,
    negate : a -> a
}

let num_Int = {
    ord = ord_Int,
    (+) = semigroup_Int_Add.append,
    (-) = \l r -> l #Int- r,
    (*) = semigroup_Int_Mul.append,
    (/) = \l r -> l #Int/ r,
    negate = \x -> 0 #Int- x
}

let num_Float : Num Float = {
    ord = ord_Float,
    (+) = semigroup_Float_Add.append,
    (-) = \l r -> l #Float- r,
    (*) = semigroup_Float_Mul.append,
    (/) = \l r -> l #Float/ r,
    negate = \x -> 0.0 #Float- x
}

type Category (cat : Type -> Type -> Type) = { id : cat a a, compose : cat b c -> cat a b -> cat a c }

let make_Category category : Category cat -> _ =
    let { id, compose } = category

    /// Right-to-left composition. Alias for `compose`.
    let (<<) : cat b c -> cat a b -> cat a c = compose
    /// Left-to-right composition. Alias for `compose`, but with the arguments flipped.
    let (>>) f g : cat a b -> cat b c -> cat a c = compose g f

    { id, compose, (<<), (>>) }

let category_Function : Category (->) = {
    id = \x -> x,
    compose = \f g x -> f (g x)
}

/// The identity function, where `id x == x`
let id : a -> a = category_Function.id

/// const `x` creates a function which always returns `x`
let const x _ : a -> b -> a = x

/// flip `f` takes creates a new function which takes its two arguments in reverse order
let flip f : (a -> b -> c) -> b -> a -> c = \x y -> f y x

/// Backward function application, where `f <| x == f x`
let (<|) f x : (a -> b) -> a -> b = f x

/// Forward function application, where `x |> f == f x`
let (|>) x f : a -> (a -> b) -> b = f x

/// Right-to-left function composition
let (<<) : (b -> c) -> (a -> b) -> a -> c = (make_Category category_Function).(<<)

/// Left-to-right function composition
let (>>) : (a -> b) -> (b -> c) -> a -> c = (make_Category category_Function).(>>)

/// A `Functor` represents an action on a parameterized type which does not
/// change the structure with the mapped type.
///
/// The following laws should hold:
///
/// * `map id == id`
/// * `map (f << g) == map f << map g`
type Functor f = {
    /// Apply the supplied function to the contents of `f a`, converting it to
    /// an `f b`
    ///
    /// # Examples
    ///
    /// * `applicative_Option.map show_Int.show (Some 1) == Some "1"`
    /// * `result.applicative.map show_Int.show (Some 1) == Ok "1"`
    /// * `list.functor.map show_Int.show (list.of [1, 2]) == list.of ["1", "2"]`
    ///
    /// # Note
    ///
    /// * Known as `fmap` in Haskell
    map : (a -> b) -> f a -> f b
}

let functor_Function : Functor ((->) a) = { map = category_Function.compose }

let functor_Option : Functor Option = {
    map = \f x ->
        match x with
        | Some y -> Some (f y)
        | None -> None
}

let functor_IO : Functor IO = { map = \f -> io_flat_map (\x -> io_wrap (f x)) }

type Applicative (f : Type -> Type) = {
    functor : Functor f,
    /// Like `functor.map`, but this time the supplied function is embedded in `f`
    ///
    /// # Note
    ///
    /// * Known as `(<*>)` in Haskell
    apply : f (a -> b) -> f a -> f b,
    /// Wrap the supplied value in `f`
    ///
    /// # Examples
    ///
    /// * `applicative_Option.wrap 1 == Some 1`
    /// * `result.applicative.wrap 1 == Ok 1`
    /// * `list.applicative.wrap 1 == list.of [1]`
    ///
    /// # Note
    ///
    /// * Known as `pure` in Haskell
    wrap : a -> f a
}

// FIXME: Causes panic in VM: thread 'main' panicked at 'Op Split called on non data type', tests/main.rs:32:8
// let make_Applicative applicative : Applicative f -> _ =
let make_Applicative applicative =
    let { functor, apply, wrap } = applicative

    let (<*>) : _ (a -> b) -> _ a -> _ b = apply
    let (<*) l r : _ a -> _ b -> _ a = functor.map const l <*> r
    let (*>) l r : _ a -> _ b -> _ b = functor.map (const id) l <*> r

    let map2 f a b : (a -> b -> c) -> _ a -> _ b -> _ c = (functor.map f a) <*> b
    let map3 f a b c : (a -> b -> c -> d) -> _ a -> _ b -> _ c -> _ d =
        (functor.map f a) <*> b <*> c

    { functor, apply, wrap, (<*>), (<*), (*>), map2, map3 }

let applicative_Function : Applicative ((->) a) = {
    functor = functor_Function,
    apply = \f g x -> f x (g x),
    wrap = const
}

let applicative_Option : Applicative Option = {
    functor = functor_Option,
    apply = \f x ->
        match (f, x) with
        | (Some g, Some y) -> Some (g y)
        | _ -> None,
    wrap = \x -> Some x
}

let applicative_IO : Applicative IO =
    let wrap = io_wrap
    let apply f x = io_flat_map (\g -> io_flat_map (\y -> wrap (g y)) x) f

    { functor = functor_IO, apply, wrap }

type Alternative f = { applicative : Applicative f, or : f a -> f a -> f a, empty : f a }

let alternative_Option : Alternative Option = {
    applicative = applicative_Option,
    or = \x y ->
        match x with
        | Some _ -> x
        | None -> y,
    empty = None
}

let make_Alternative alternative : Alternative f -> _ =
    let { applicative, or, empty } = alternative

    let (<|>) : f a -> f a -> f a = or

    { applicative, or, empty, (<|>) }

/// A generalised interface for imperatively sequencing actions
type Monad (m : Type -> Type) = {
    applicative : Applicative m,
    /// This can be seen as akin to sequential variable binding in an
    /// imperative language. For example in Javascript:
    ///
    /// ```js
    /// var x = call_fallible("hello");
    /// do_something(x);
    /// ```
    ///
    /// In gluon this would look like:
    ///
    /// ```gluon
    /// result.monad.flat_map (\x -> do_something x) (call_fallible "hello")
    /// ```
    ///
    /// Note that it is sometimes more ergonomic to use the `(>>=)` operator:
    ///
    /// ```gluon
    /// let { (>>=) } = make_Monad result.monad
    ///
    /// call_fallible "hello" >>= (\x -> do_something x)
    /// ```
    ///
    /// # Note
    ///
    /// * Known as `(=<<) or `flip (>>=)` in Haskell
    /// * Known as `Option::and_then` and `Result::and_then` in Rust
    flat_map : (a -> m b) -> m a -> m b
}

let make_Monad monad : Monad m -> _ =
    let { applicative, flat_map } = monad
    let { (*>), wrap } = make_Applicative applicative
    let { id } = category_Function

    let (=<<) : (a -> m b) -> m a -> m b = flat_map
    let (>>=) : m a -> (a -> m b) -> m b = flip flat_map

    let join mm : m (m a) -> m a = mm >>= id

    { applicative, flat_map, (=<<), (>>=), join }

let monad_Function : Monad ((->) a) = {
    applicative = applicative_Function,
    flat_map = \f m x -> f (m x) x
}

let monad_Option : Monad Option = {
    applicative = applicative_Option,
    flat_map = \f m ->
        match m with
        | Some x -> f x
        | None -> None
}

let monad_IO : Monad IO = {
    applicative = applicative_IO,
    flat_map = io_flat_map
}

/// `Show a` represents a conversion function from `a` to a readable string.
type Show a = { show : a -> String }

let show_Unit : Show () = { show = const "()" }

let show_Bool : Show Bool = { show = \x -> if x then "True" else "False" }

let show_Int : Show Int = { show = prim.show_int }

let show_Float : Show Float = { show = prim.show_float }

let show_Char : Show Char = { show = prim.show_char }

let show_Option : Show a -> Show (Option a) = \d ->
    let (++) = string_prim.append

    let show o =
        match o with
        | Some x -> "Some (" ++ d.show x ++ ")"
        | None -> "None"

    { show }

type Foldable (f : Type -> Type) = {
    foldr : (a -> b -> b) -> b -> f a -> b,
    foldl : (b -> a -> b) -> b -> f a -> b
}

let make_Foldable foldable : Foldable t -> _ =
    let { foldr, foldl } = foldable
    let { (+) } = num_Int

    let concat monoid : Monoid m -> t m -> m =
        foldr monoid.semigroup.append monoid.empty

    let concat_map monoid f : Monoid m -> (a -> m) -> t a -> m =
        foldr (f >> monoid.semigroup.append) monoid.empty

    let fold_m monad f z : Monad m -> (a -> b -> m a) -> a -> t b -> m a =
        foldl (\acc b -> monad.flat_map (flip f b) acc) (monad.applicative.wrap z)

    let find pred : (a -> Bool) -> t a -> Option a =
        let go acc next =
            match acc with
            | None -> if pred next then Some next else None
            | Some _ -> acc

        foldl go None

    let find_map pred : (a -> Option b) -> t a -> Option b =
        let go acc next =
            match acc with
            | None -> pred next
            | Some _ -> acc

        foldl go None

    let all pred : (a -> Bool) -> t a -> Bool =
        foldl (\acc x -> acc && pred x) True

    let any pred : (a -> Bool) -> t a -> Bool =
        foldl (\acc x -> acc || pred x) False

    let elem eq : Eq a -> a -> t a -> Bool =
        any << eq.(==)

    let notElem eq x : Eq a -> a -> t a -> Bool =
        not << elem eq x

    let count : t a -> Int =
        foldl (\acc _ -> acc + 1) 0

    {
        foldr,
        foldl,
        fold_m,
        concat,
        concat_map,
        find,
        find_map,
        all,
        any,
        elem,
        notElem,
        count
    }

let foldable_Option : Foldable Option = {
    foldr = \f z o ->
        match o with
        | None -> z
        | Some x -> f x z,
    foldl = \f z o ->
        match o with
        | None -> z
        | Some x -> f z x
}

type Traversable t = {
    functor : Functor t,
    foldable : Foldable t,
    traverse : Applicative m -> (a -> m b) -> t a -> m (t b)
}

let make_Traversable traversable : Traversable t -> _ =
    let { functor, foldable, traverse } = traversable

    let sequence applicative : Applicative m -> t (m a) -> m (t a) = traverse applicative id
    let for applicative x f : Applicative m -> t a -> (a -> m b) -> m (t b) =
        traverse applicative f x

    { functor, foldable, traverse, sequence, for }

let traversable_Option : Traversable Option = {
    functor = functor_Option,
    foldable = foldable_Option,
    traverse = \app f o ->
        match o with
        | None -> app.wrap None
        | Some x -> app.functor.map Some (f x)
}

{
    Bool,
    Ordering,
    Option,

    unwrap,

    not,
    xor,

    Semigroup,
    make_Semigroup,
    semigroup_Function,
    semigroup_Option,
    semigroup_Option_First,
    semigroup_Option_Last,
    semigroup_Int_Add,
    semigroup_Int_Mul,
    semigroup_Float_Add,
    semigroup_Float_Mul,
    semigroup_Bool_And,
    semigroup_Bool_Or,
    semigroup_Bool_Xor,
    semigroup_Ordering,

    Monoid,
    monoid_Function,
    monoid_Option,
    monoid_Option_First,
    monoid_Option_Last,
    monoid_Int_Add,
    monoid_Int_Mul,
    monoid_Float_Add,
    monoid_Float_Mul,
    monoid_Bool_And,
    monoid_Bool_Or,
    monoid_Bool_Xor,
    monoid_Ordering,

    Group,
    group_Int_Add,
    group_Float_Add,
    group_Float_Mul,
    group_Bool_Xor,

    Eq,
    eq_Unit,
    eq_Bool,
    eq_Option,
    eq_Float,
    eq_Int,
    eq_Char,

    Ord,
    make_Ord,
    ord_Unit,
    ord_Bool,
    ord_Option,
    ord_Float,
    ord_Int,
    ord_Char,

    Category,
    make_Category,
    category_Function,

    Functor,
    functor_Option,
    functor_IO,

    Applicative,
    make_Applicative,
    applicative_Option,
    applicative_IO,

    Alternative,
    make_Alternative,
    alternative_Option,

    Monad,
    make_Monad,
    monad_Option,
    monad_IO,

    Foldable,
    make_Foldable,
    foldable_Option,

    Traversable,
    make_Traversable,
    traversable_Option,

    Num,
    num_Int,
    num_Float,

    id,
    const,
    flip,
    (<|),
    (|>),
    (<<),
    (>>),

    Show,
    show_Unit,
    show_Bool,
    show_Int,
    show_Float,
    show_Char,
    show_Option
}
