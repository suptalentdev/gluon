//! A simple parser combinator library

let prelude = import! std.prelude
let { Functor, Applicative, Alternative, Monad, (<>) } = prelude
let { id, flip, (>>), (<<), (|>), (<|) } = import! std.function

let { Bool } = import! std.bool
let char @ { Char, ? } = import! std.char
let int = import! std.int
let list @ { List } = import! std.list
let { Option } = import! std.option
let { Result } = import! std.result
let string @ { String, ? } = import! std.string

// TODO How handle atom streams generically? Stream-like interface?
// TODO How handle error position generically? Zip stream with enumeration?
type Parser s e a = StateT s (Result e) a
// TODO How have Parser (Result Err) on surface but Streamer type (Option) internally?
//   How handle custom error types this way? Do I need to build mini-failure lib?

// use implicit argument that user fills in with error type and end case?
let sr_to_psr end sr : e -> Streamer s a -> Parser s e a =
    sr >> \opt -> match opt with
        | Some next -> Ok next
        | None -> Err end

// terrible idea?
let any_atom : [Streamlike atm srm] -> Parser srm e atm =
    sr_to_psr ? uncons

let take n : [Streamlike atm srm] -> Int -> Parser srm e () =
    \xs -> Ok {value = (), state = streamlike.take n xs}

// TODO What error type should library functions return?
let satisfy_map pred : [Streamlike atm srm] -> (atm -> Option a) -> Parser srm e a =
    any_atom >>= \atm ->
        match pred atm with
        | Some a -> wrap a
        | None -> // TODO Error handling

let satisfy pred : [Streamlike atm srm] -> (atm -> Bool) -> Parser srm e atm =
    satisfy_map (\c -> if pred c then Some c else None)

let atom x : [Streamlike atm srm] -> [Eq atm] -> atm -> Parser srm e atm =
    satisfy <| (==) x

rec let token ts : [Streamlike atm srm] -> [Streamlike atm tknsrm] -> [Eq atm] -> tknsrm -> Parser srm e atm =
    any_atom >>= \x ->
        match any_atom ts with
        | Ok {value = t, state = ts'} ->
            if x == t then
                map (\_ -> ts) (token ts')
            else
                Err ? // TODO Error handling
        | Err ? -> wrap ts // TODO Error handling: needs to be EndOfStream error
        | Err e -> (\_ -> Err e) // unreachable?

// end - matches end of stream
// take_while1?
// many
// many1
// skip_many?
// between
// one_of
// sep_by
// sep_by1
// chain
// chain1
// parse

type Position = Int
type OffsetString = { start : Position, end : Position, buffer : String }
type Error = { position : Position, message : String }
type StringParser a = Parser OffsetString Error a

let eolsym c : Char -> Bool =
    elem c ['\r', '\n']

let space : [Streamlike Char srm] -> Parser srm e Char =
    atom ' '

let eol : [Streamlike Char srm] -> Parser srm e Char = (atom '\r' *> atom '\n') <|> atom '\n' <|> atom '\r'

let whitespace : [Streamlike Char srm] -> Parser srm e Char =
    satisfy char.is_whitespace

let letter : [Streamlike Char srm] -> Parser srm e Char =
    satisfy char.is_alphabetic

let digit : [Streamlike Char srm] -> Parser srm e Char =
    satisfy <| flip char.is_digit 10

let alphanum : [Streamlike Char srm] -> Parser srm e Char =
    letter <|> digit

// spaces
// whitespace
// whitespaces?
// end of line / new line
// rest of line (all but line break)?

type ByteParser a = // TODO


// practice parser implementation
type PsrErr =
    | ParseFailure String
    | EndOfStream

type Parser a = Parser [Byte] PsrErr a
