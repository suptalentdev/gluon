//@NO-IMPLICIT-PRELUDE

/// A `Functor` represents an action on a parameterized type which does not
/// change the structure with the mapped type.
///
/// The following laws should hold:
///
/// * `map id == id`
/// * `map (f << g) == map f << map g`
/// @implicit
type Functor f = {
    /// Apply the supplied function to the contents of `f a`, converting it to
    /// an `f b`
    ///
    /// # Examples
    ///
    /// * `option.functor.map show_Int.show (Some 1) == Some "1"`
    /// * `result.functor.map show_Int.show (Some 1) == Ok "1"`
    /// * `list.functor.map show_Int.show (list.of [1, 2]) == list.of ["1", "2"]`
    ///
    /// # Note
    ///
    /// * Known as `fmap` in Haskell
    map : forall a b . (a -> b) -> f a -> f b
}

let map ?functor : [Functor f] -> (a -> b) -> f a -> f b = functor.map

/// @implicit
type Applicative (f : Type -> Type) = {
    functor : Functor f,
    /// Like `functor.map`, but this time the supplied function is embedded in `f`
    ///
    /// # Note
    ///
    /// * Known as `(<*>)` in Haskell
    apply : forall a b . f (a -> b) -> f a -> f b,
    /// Wrap the supplied value in `f`
    ///
    /// # Examples
    ///
    /// * `option.applicative.wrap 1 == Some 1`
    /// * `result.applicative.wrap 1 == Ok 1`
    /// * `list.applicative.wrap 1 == list.of [1]`
    ///
    /// # Note
    ///
    /// * Known as `pure` in Haskell
    wrap : forall a . a -> f a
}

let wrap ?app : [Applicative f] -> a -> f a = app.wrap
let apply ?app : [Applicative f] -> f (a -> b) -> f a -> f b = app.apply
let (<*>) ?app : [Applicative f] -> f (a -> b) -> f a -> f b = app.apply
let (<*) ?app l r : [Applicative f] -> f a -> f b -> f a = app.functor.map (\x _ -> x) l <*> r
let (*>) ?app l r : [Applicative f] -> f a -> f b -> f b = app.functor.map (\_ x -> x) l <*> r

let map2 ?app f a b : [Applicative f] -> (a -> b -> c)
        -> f a
        -> f b
        -> f c
    = (app.functor.map f a) <*> b
let map3 ?app f a b c : [Applicative f] -> (a -> b -> c -> d) -> f a -> f b -> f c -> f d =
    (app.functor.map f a) <*> b <*> c

{
    Functor,
    map,
    Applicative,
    apply, wrap, (<*>), (<*), (*>), map2, map3,
}
