let prelude = import! "std/prelude.glu"
and { Ordering, Ord, Option, List, Monoid, Functor, Applicative, Foldable, Traversable } = prelude

type Map k a = | Bin k a (Map k a) (Map k a) | Tip

let empty = Tip

let singleton k v = Bin k v empty empty

and make ord : Ord k -> _ =
    let find k m : k -> Map k a -> Option a =
        match m with
        | Bin k2 v l r ->
            match ord.compare k k2 with
            | LT -> find k l
            | EQ -> Some v
            | GT -> find k r
        | Tip -> None

    let insert k v m : k -> a -> Map k a -> Map k a =
        match m with
        | Bin k2 v2 l r ->
            match ord.compare k k2 with
            | LT -> Bin k2 v2 (insert k v l) r
            | EQ -> Bin k v l r
            | GT -> Bin k2 v2 l (insert k v r)
        | Tip -> Bin k v empty empty

    let to_list m : Map k a -> List { key : k, value : a } =
        let (++) = prelude.monoid_List.append
        match m with
        | Bin key value l r -> to_list l ++ Cons { key, value } (to_list r)
        | Tip -> Nil

    let map f m : (a -> b) -> Map k a -> Map k b =
        match m with
        | Tip -> Tip
        | Bin k x l r -> Bin k (f x) (map f l) (map f r)

    let map_with_key f m : (k -> a -> b) -> Map k a -> Map k b =
        match m with
        | Tip -> Tip
        | Bin k x l r -> Bin k (f k x) (map_with_key f l) (map_with_key f r)

    let foldr f z m : (a -> b -> b) -> b -> Map k a -> b =
        match m with
        | Tip -> z
        | Bin _ x l r -> foldr f (f x (foldr f z r)) l

    let foldl f z m : (a -> b -> a) -> a -> Map k b -> a =
        match m with
        | Tip -> z
        | Bin _ x l r -> foldl f (f (foldl f z l) x) r

    let foldr_with_key f z m : (k -> a -> b -> b) -> b -> Map k a -> b =
        match m with
        | Tip -> z
        | Bin k v l r -> foldr_with_key f (f k v (foldr_with_key f z r)) l

    let foldl_with_key f z m : (a -> k -> b -> a) -> a -> Map k b -> a =
        match m with
        | Tip -> z
        | Bin k x l r -> foldl_with_key f (f (foldl_with_key f z l) k x) r

    let traverse_with_key app f m : Applicative t -> (k -> a -> t b) -> Map k a -> t (Map k b) =
        let { map3 } = prelude.make_Applicative app

        let go m =
            match m with
            | Tip -> app.pure Tip
            | Bin k v l r ->
                map3 (prelude.flip (Bin k)) (go l) (f k v) (go r)

        go m

    let traverse app f : Applicative t -> (a -> t b) -> Map k a -> t (Map k b) =
        traverse_with_key app (prelude.const f)

    let append l r = foldr_with_key insert l r

    let monoid : Monoid _ = { append, empty }
    let functor : Functor _ = { map }
    let foldable : Foldable _ = { foldr, foldl }
    let traversable : Traversable _ = { functor, foldable, traverse }

    {
        monoid,
        functor,
        foldable,
        traversable,
        singleton,
        find,
        insert,
        to_list,
        map_with_key,
        foldr_with_key,
        foldl_with_key,
        traverse_with_key
    }

{ Map, make }
